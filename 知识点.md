1.vue2 和 vue3 有哪些不同？
① 双向数据绑定的原理不同，vue2 使用的是发布订阅者模式和 Object.defineProperty()数据劫持，vu3 是使用的 Proxy 数据代理和 Reflect 反射 api
② vue3 支持拥有多个根节点
③ 所用 api 不同，vue3 使用组合 api
④ 定义变量的方法不同
⑤ 生命周期的不同，vue3 使用 setup 代替了 vue2 的 beforeCreate 和 created 2. 如何去做首屏优化？
① 使用路由懒加载
② 非首屏组件使用异步组件
③ 首屏不重要的组件做延迟加载
④ 减小首屏上 js,css 等资源文件的大小
⑤ 图片懒加载
⑥ 使用精灵图请求 3. js 操作数组的方法
push ,pop ,shift ,unshift , splice ,sort 会改变原数组
join ,filter ,some, reduce ,map ,concat 不会改变原数组 4. js 检验数据类型的有哪些？
typeOf:只能判断基本数据类型
Object.property.toString.call() 可以判断所有数据类型
instance 只能判断引用数据类型
().construtor 得到()的基类 4. 闭包
可以读取其他函数内部变量的函数。
闭包的特点：变量不会被垃圾回收机制回收，创建私有空间
闭包的确定：闭包较多时会消耗内存，导致页面性能下降
闭包的作用：延长变量的生命周期，创建私有作用域 5.事件委托
事件委托又叫事件代理，原理是利用事件冒泡的机制来实现，也就是说把子元素的事件绑定在他的父元素上。 6.原型和原型链
原型是一个对象，是函数上的一个 prototype 属性，通过改函数实例化出来的对象可以继承原型上的所有属性和方法。
原型链:一个实例对象在调用属性和方法时，依此会从实例本身，构建函数原型，原型的原型上去查找，直到查找到 null，没有找到属性返回 undefined，方法报错，这样查找所形成的链条就叫做原型链。
7.new 的时候都做了那些操作？
① 创建一个新的空对象
② 将空对象的**proto**属性指向函数的原型
③ 把构造函数的 this 绑定到新的空对象身上，并把参数传入
④ 根据构造函数的返回值类型判断，如果是值类型就返回新对象，如果是引用类型就返回这个引用类型
8.js 中的继承
① 原型链继承
实现原理：子类的原型指向父类的实例
缺点：当原型链中有引用类型的值时，该引用类型的值将会被所有函数实例共享
创建子类是不能向父类的构造函数中传参
② 构造函数继承
实现原理：在子类的构造函数中执行父类的构造函数，并为其绑定 this
缺点：无法获取到父类构造函数上的属性和方法
③ 组合继承
实现原理：在子类的构造函数中执行父类的的构造函数，并为其绑定 this，把父类的原型赋值给子类的原型
④ Class 类实现继承，Class 通过 extends 关键字实现继承
9.ES6 的新特性
① 新增了块级作用域(let ,const)
② 新增了定义类的语法糖
③ 新增了解构赋值
④ 新增了函数参数默认，箭头函数(不能作为构建函数，没有 arguments，不能使用 call,bind,apply 改变 this)
⑤Promise(解决回调地狱的问题，三种状态:pending，fulfilled,rejected)
⑥ 新增了 set(数据唯一性，值不重复)，map(map 的 key 不受限制)数据结构，symbol 数据类型(代表独一无二的值)
⑦ 新增了模块化(import，export)
⑧ 新增了数组 api ，(map,find,findIndex,filter,some,reduce)
10.async 和 await
同步代码做异步操作，两者必须搭配使用，调用函数会返回 Promise
11.call,bind,apply 的区别
call 接收的是一个参数列表，apply 接收的是一个数组，bind 是返回一个改变 this 指向的函数 12.事件循环
js 是一个单线程的脚本语言，在执行任务时会先执行同步任务，然后取执行任务队列里的任务，执行宏任务时会先检查是否有微任务，有微任务会先执行所有的微任务，然后在执行宏任务，全部执行完成后等待主线程的调用，调用完成后在去任务队列里查看是否有异步任务，这样一个循环往复的过程就叫事件循环。
宏任务有：setTimeout,setInterval,Ajax 请求，UI 事件，requestAnimationFrame
微任务有：async/await,Promise.then，MutationObserver，Promise 回调函数
13.get 和 post 的区别
①get 一般用来请求数据，post 一般是用来提交数据
②get 是 url 路径传参，安全性比较低，参数长度有限制，post 是 body 传参，安全性比 get 高，参数长度没有限制
③get 请求刷新浏览器或者浏览器回退没有影响，post 会重新请求一遍
④get 请求会被浏览器缓存，post 不会
14.Token 一般存放在哪里？各有什么不同？
① 储存在 localStorage 中，但是每次调用接口时都要把当做一个字段传给后台
② 储存在 cookie 中，每次请求接口都会自动携带，但是不能跨域
③ 存储在 sessionStorage 中，每次调用接口时要放在 HTTP 请求头的 Authorization 字段中 15.浏览器的缓存策略
浏览器的缓存分 强缓存(本地缓存)，协商缓存(弱缓存)
强缓存：不发起请求，直接使用缓存里的内容，浏览器把 JS,Css,Image 等存到内存中，下次用户访问直接从浏览器内存中取，提高性能。
协商缓存：需要向后端发送请求，通过判断来决定是否使用协商缓存，如果请求内容没有变化，则返回 304，浏览器就用缓存里的内容。
强缓存的触发条件：http1.0:时间戳响应头
http1.1,Cache-control 响应头
弱缓存(协商缓存)触发条件：http1.0：if-modified-since 请求头，last-modified 响应头。
http1.1 触发条件：if-none-match 请求头，Etag 响应头。 
16.同源策略
http:(协议)//www(子域名).aaa(主域名).com:8080(端口号)/index/index.vue(资源路径)
同源策略是指协议，域名，端口号三者一致，否则会产生跨域。
跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截。
解决跨域的方法，jsonp,cors,websocket,反向代理
17.JWT令牌
JWT全名JSON WEB Token。有头部，有效载荷，签名三部分组成
18.http状态响应码
 200：响应成功
 302：页面或者请求进行了多次重定向
 400：参数不正确
 404：找不到请求
 500：内部服务器错误(后端接口报错)
 19.crypto-js 依赖加密解密