1.vue2 和 vue3 有哪些不同？
① 双向数据绑定的原理不同，vue2 使用的是发布订阅者模式和 Object.defineProperty()数据劫持，vu3 是使用的 Proxy 数据代理和 Reflect 反射 api
② vue3 支持拥有多个根节点
③ 所用 api 不同，vue3 使用组合 api
④ 定义变量的方法不同
⑤ 生命周期的不同，vue3 使用 setup 代替了 vue2 的 beforeCreate 和 created 
2. 如何去做首屏优化？
① 使用路由懒加载
② 非首屏组件使用异步组件
③ 首屏不重要的组件做延迟加载
④ 减小首屏上 js,css 等资源文件的大小
⑤ 图片懒加载
⑥ 使用精灵图请求
 3. js 操作数组的方法
push ,pop ,shift ,unshift , splice ,sort 会改变原数组
join ,filter ,some, reduce ,map ,concat 不会改变原数组 4. js 检验数据类型的有哪些？
typeOf:只能判断基本数据类型
Object.property.toString.call() 可以判断所有数据类型
instance 只能判断引用数据类型
().construtor 得到()的基类
4. 闭包
可以读取其他函数内部变量的函数。
闭包的特点：变量不会被垃圾回收机制回收，创建私有空间
闭包的确定：闭包较多时会消耗内存，导致页面性能下降
闭包的作用：延长变量的生命周期，创建私有作用域
5.事件委托
 事件委托又叫事件代理，原理是利用事件冒泡的机制来实现，也就是说把子元素的事件绑定在他的父元素上。
 6.原型和原型链
 原型是一个对象，是函数上的一个prototype属性，通过改函数实例化出来的对象可以继承原型上的所有属性和方法。
 原型链:一个实例对象在调用属性和方法时，依此会从实例本身，构建函数原型，原型的原型上去查找，直到查找到null，没有找到属性返回undefined，方法报错，这样查找所形成的链条就叫做原型链。
 7.new的时候都做了那些操作？
 ① 创建一个新的空对象
 ②将空对象的__proto__属性指向函数的原型
 ③把构造函数的this绑定到新的空对象身上，并把参数传入
 ④根据构造函数的返回值类型判断，如果是值类型就返回新对象，如果是引用类型就返回这个引用类型
8.js中的继承
①原型链继承
 实现原理：子类的原型指向父类的实例
 缺点：当原型链中有引用类型的值时，该引用类型的值将会被所有函数实例共享
      创建子类是不能向父类的构造函数中传参
②构造函数继承
 实现原理：在子类的构造函数中执行父类的构造函数，并为其绑定this
    缺点：无法获取到父类构造函数上的属性和方法
③组合继承
实现原理：在子类的构造函数中执行父类的的构造函数，并为其绑定this，把父类的原型赋值给子类的原型
④ Class类实现继承，Class通过extends 关键字实现继承
9.ES6的新特性
①新增了块级作用域(let ,const)
②新增了定义类的语法糖
③新增了解构赋值
④新增了函数参数默认，箭头函数(不能作为构建函数，没有arguments，不能使用call,bind,apply改变this)
⑤Promise(解决回调地狱的问题，三种状态:pending，fulfilled,rejected)
⑥新增了set(数据唯一性，值不重复)，map(map的key不受限制)数据结构，symbol数据类型(代表独一无二的值)
⑦新增了模块化(import，export)
⑧新增了数组api ，(map,find,findIndex,filter,some,reduce)
10.async和 await
  同步代码做异步操作，两者必须搭配使用，调用函数会返回Promise
11.call,bind,apply的区别
 call接收的是一个参数列表，apply接收的是一个数组，bind是返回一个改变this指向的函数
 12.事件循环
 js是一个单线程的脚本语言，在执行任务时会先执行同步任务，然后取执行任务队列里的任务，执行宏任务时会先检查是否有微任务，有微任务会先执行所有的微任务，然后在执行宏任务，全部执行完成后等待主线程的调用，调用完成后在去任务队列里查看是否有异步任务，这样一个循环往复的过程就叫事件循环。
 宏任务有：setTimeout,setInterval,Ajax请求，UI事件，requestAnimationFrame
 微任务有：async/await,Promise.then，MutationObserver，Promise 回调函数
 13.get和post的区别
 ①get一般用来请求数据，post一般是用来提交数据
 ②get是url路径传参，安全性比较低，参数长度有限制，post是body传参，安全性比get高，参数长度没有限制
 ③get请求刷新浏览器或者浏览器回退没有影响，post会重新请求一遍
 ④get请求会被浏览器缓存，post不会
14.Token一般存放在哪里？各有什么不同？
  ①储存在localStorage中，但是每次调用接口时都要把当做一个字段传给后台
  ②储存在cookie中，每次请求接口都会自动携带，但是不能跨域
  ③存储在sessionStorage中，每次调用接口时要放在HTTP请求头的Authorization字段中